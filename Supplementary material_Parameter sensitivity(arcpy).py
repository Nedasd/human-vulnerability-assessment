#!/usr/bin/python
# -*- coding: UTF-8 -*-
# this code is designed for simulating the parameters sensitivity
import arcpy,os
import math,random

arcpy.env.overwriteOutput = True

fieldPrecision = 18
fieldScale = 11

point_number=0
list_angle_box=[]
while point_number<10000:
    point_number+=1
    # set run direction, random to left or right?
    run_angle = random.random()
    if run_angle > 0.5:
        run_angle = 1#to right
    else:
        run_angle = -1# to left
    list_angle_box.append(run_angle)
    #print(list_angle_box)
else:
    print("get full list angle box")

# Firstly, add the escape direction

# by the following code to generate the random point
origin_shp="E:/#ned/#s_A/1w_point.shp"
# arcpy.CreateRandomPoints_management("E:/", origin_shp, "F:/potential_people_location.shp", "", 10000, "", "POINT", "")
arcpy.CopyFeatures_management("E:/#ned/store/1w_point.shp", origin_shp)
try:
    arcpy.AddField_management(origin_shp, "angle", "DOUBLE", fieldPrecision, fieldScale)
    arcpy.AddField_management(origin_shp, "mark", "DOUBLE", fieldPrecision, fieldScale)
except:
    print("#angle# field had been existed")

# add #angle# and #mark# field
add_cursor = arcpy.UpdateCursor(origin_shp)
i=0
for add_row in add_cursor:
    add_row.getValue("angle")
    add_row.setValue("angle", list_angle_box[i])

    add_row.getValue("mark")
    add_row.setValue("mark", str(i+1))

    add_cursor.updateRow(add_row)
    i += 1

# make store folder for merge
try:
    make_path_merge = "E:\\#ned\\#s_A\\merge\\"
    os.mkdir(make_path_merge)

    make_path_merge = "E:\\#ned\\#s_A\\#step\\"
    os.mkdir(make_path_merge)

    make_path_map = "E:\\#ned\\#s_A\\map\\"
    os.mkdir(make_path_map)
except:
    print("folder merge already exists")

# copy the internal step0
arcpy.CopyFeatures_management("E:/#ned/store/step_0.shp", "E:/#ned/#s_A/merge/internal_step0.shp")
arcpy.CopyFeatures_management(origin_shp, "E:/#ned/#s_A/#step/step_0.shp")
# start to iteration
time_step = 0
while time_step < 50:
    time_step = time_step + 1

    # copy the origin_shp, at this time the internal point is still exist
    from_copy_shp = "E:/#ned/#s_A/#step/step_" + str(time_step - 1) + ".shp"
    calculate_shp = "E:/#ned/#s_A/#step/step_" + str(time_step) + ".shp"
    arcpy.CopyFeatures_management(from_copy_shp, calculate_shp)

    # delete the internal point, that is the destroyed people
    arcpy.env.workspace = "E:/#ned/#s_A/merge"
    mark_shp = "E:/#ned/#s_A/merge/internal_step"+str(time_step-1) + ".shp"
    destroy_box = []

    # record the delete mark
    mark_Cursor = arcpy.da.UpdateCursor(mark_shp, ["mark"])
    for destroy_mark in mark_Cursor:
        destroy_box.append(destroy_mark)
        print(destroy_box)
    # delete the record point
    arcpy.env.workspace = "E:/#ned/#s_A/#step"
    delete_Cursor = arcpy.da.UpdateCursor(calculate_shp, ["mark"])
    try:
        for row in delete_Cursor:
            if row in destroy_box:
                delete_Cursor.deleteRow()
                print("delete the " + str(row))
    except:
        print("none destroyed people")
    del destroy_box[:]

    # add the field for move
    arcpy.AddField_management(calculate_shp, "distance", "DOUBLE", fieldPrecision, fieldScale)

    # add move_angle and move_distance
    arcpy.env.workspace = "E:/#ned/#s_A/step_" + str(time_step)
    move_angle = math.pi / 180
    # start to move the point
    Cal_Cursor = arcpy.da.UpdateCursor(calculate_shp, ["shape@X", "shape@Y", "angle"])

    # remember to change the run velocity (3)
    # the escape angle 16, 29, 61 represents the escape direction, and it was calculated manually.
    # for route A
    for row in Cal_Cursor:
        if row[2]<0:#-74=-90+16
            row[0] = row[0] - math.cos(16 * move_angle) * (3)
            row[1] = row[1] + math.sin(16 * move_angle) * (3)
            Cal_Cursor.updateRow(row)
        elif row[2]>0:#106=90+19
            row[0] = row[0] + math.cos(16 * move_angle) * (3)
            row[1] = row[1] - math.sin(16 * move_angle) * (3)
            Cal_Cursor.updateRow(row)

    # for route B
    #for row in Cal_Cursor:
        #if row[2]<0:#-119=-74-45
            #row[0] = row[0] - math.cos(29* move_angle) * (3)
            #row[1] = row[1] - math.sin(29 * move_angle) * (3)
            #Cal_Cursor.updateRow(row)
        #elif row[2]>0:#151=90+16+45
            #row[0] = row[0] + math.cos(61 * move_angle) * (3)
            #row[1] = row[1] - math.sin(61 * move_angle) * (3)
            #Cal_Cursor.updateRow(row)

    # for route C
    #for row in Cal_Cursor:#-164=-90-74
        #row[0] = row[0] - math.cos(74* move_angle) * (3)
        #row[1] = row[1] - math.sin(74 * move_angle) * (3)
        #Cal_Cursor.updateRow(row)

    # for route D
    #for row in Cal_Cursor:
        #if time_step <= row[3]:# execution route A
            # to run A left
            #if row[2] < 0:  # -74=-90+16
                #row[0] = row[0] - math.cos(16 * move_angle) * (3)
                #row[1] = row[1] + math.sin(16 * move_angle) * (3)
            # to run A right
            #elif row[2] > 0:  # 106=90+19
                #row[0] = row[0] + math.cos(16 * move_angle) * (3)
                #row[1] = row[1] - math.sin(16 * move_angle) * (3)
        #else:# execution route B
            # to run B left
            #if row[2] < 0:  # -119=-74-45
                #row[0] = row[0] - math.cos(29 * move_angle) * (3)
                #row[1] = row[1] - math.sin(29 * move_angle) * (3)
            # to run B right
            #elif row[2] > 0:  # 151=90+16+45
                #row[0] = row[0] + math.cos(61 * move_angle) * (3)
                #row[1] = row[1] - math.sin(61 * move_angle) * (3)
        #Cal_Cursor.updateRow(row)
    arcpy.RefreshActiveView()


    # select the internal and external point
    # the largest boundary of hazard zone, to change the "time_step+n" representing early warning time,
    # eg n=2 represents the potential victims had 2 s effective early warning time.
    cut_shp =  "E:/#ned/boundary100/case" + str(time_step+2) + ".shp"# take "str(time_step+2)" represent Early warning time, here EWt=0 s, respons time=2s
    internal_shp = "E:/#ned/#s_A/merge/internal_step" + str(time_step) + ".shp"
    external_shp = "E:/#ned/#s_A/merge/external_step" + str(time_step) + ".shp"
    try:
        arcpy.Clip_analysis(calculate_shp, cut_shp, internal_shp, "0.01 Meters")
        arcpy.SymDiff_analysis(calculate_shp, internal_shp, external_shp, "ALL", 0.001)
        arcpy.DeleteField_management(external_shp,["CID_1", "angle_1", "mark_1", "distance_1", "FID_intern", "FID_step_"+str(time_step)])
    except:
        print("A It did not intersect")
    # statistic the survival human number
    field = "CID"
    cursor = arcpy.SearchCursor(internal_shp)
    internal_row = cursor.next()
    # here take the "CID=0" as the common characteristics
    count_number = 0
    while internal_row:
        distance_number = internal_row.getValue(field)
        if distance_number == 0:
            count_number = count_number + 1
        else:
            print("Check the" + str(time_step) + " internal_shp field")
        internal_row = cursor.next()
    print("A step_" + str(time_step) + " survivors number:" + str(count_number))
    # write the number of survivors
    f = open("E:/#ned/#s_A/survival_number_A.txt", 'a')
    f.write("step_" + str(time_step) + " Survivors number:" + str(count_number) + "\n")
    f.close()


#### the following code is designed for selecting the destroyed points (dead position)
arcpy.env.overwriteOutput = True
arcpy.env.workspace = "F:/human vulnerability/5_cal/3.destroy position"
destroy_box = []

mark_shp = "A_warning_awareness_external_step50.shp"

mark_Cursor = arcpy.da.UpdateCursor(mark_shp, ["mark"])
for destroy_mark in mark_Cursor:
    destroy_box.append(destroy_mark)
    #print(destroy_box)

calculate_shp = "A_warning_awareness_destroy.shp"
origin_shp="F:/human vulnerability/5_cal/2.Warning/V=3, T=8/#s_A/1w_point.shp"
arcpy.CopyFeatures_management(origin_shp, calculate_shp )

arcpy.env.workspace = "F:/human vulnerability/5_cal/3.destroy position"
delete_Cursor = arcpy.da.UpdateCursor(calculate_shp, ["mark"])
for row in delete_Cursor:
    print(row)
    if row in destroy_box:
        delete_Cursor.deleteRow()
        print("delete the " + str(row))

del destroy_box[:]

survivor_shp="A_warning_awareness_survivor.shp"
arcpy.SymDiff_analysis(origin_shp, calculate_shp, survivor_shp, "ALL", 0.001)


### the following code is designed for selecting the destroyed points (dead position),
### you'd better not use the following codes with previous step.
## 1. get the dead point list
mark_shp = "A_warning_awareness_external_step50.shp"
destroyed_position = gpd.read_file(mark_shp)
destroy_box = destroyed_position["mark"].tolist()

origin_shp="F:/human vulnerability/5_cal/2.Warning/V=3, T=8/#s_A/1w_point.shp"
calculate_shp = "A_warning_awareness_destroy.shp"
# copy the shp files
def copy_shp (source_shp, copied_shp):
    shp_from_where = shapefile.Reader(source_shp)
    duplicated_shp = shapefile.Writer(copied_shp)

    duplicated_shp.fields = shp_from_where.fields[1:]

    for shape_rec in shp_from_where.iterShapeRecords():
        duplicated_shp.record(*shape_rec.record)
        duplicated_shp.shape(shape_rec.shape.__geo_interface__)
    duplicated_shp.close()
copy_shp(source_shp=origin_shp,
         copied_shp=calculate_shp)
## delect the dead point from the step_0
current_survival_point = gpd.read_file(calculate_shp)
current_survival_point_list = current_survival_point["mark"].tolist()

try:
    for delete_number in destroy_box:
        before_update = gpd.read_file(calculate_shp)
        after_update = before_update.drop(before_update[before_update["mark"] == delete_number].index)
        print("delete the " + str(delete_number))

        after_update.to_file(calculate_shp, driver="ESRI Shapefile", encoding="utf-8")
        print("delete the " + str(delete_number))
except:
    print("none destroyed people")

del destroy_box[:]
# get the survivor point from the origin calculated shp
SymDiff_analysis = gpd.overlay(origin_shp, calculate_shp, how="symmetric_difference")
SymDiff_analysis.to_file(survivor_shp)