#!/usr/bin/python
# -*- coding: UTF-8 -*-
# this code is designed for simulating the parameters sensitivity.
import math,random,os,shapefile,numpy
from osgeo import ogr
import geopandas as gpd
from geopandas import overlay
import pandas as pd

## make random number to mark the point
point_number=0
list_angle_box=[]
while point_number<10000:
    point_number+=1
    # set run direction, random to left or right?
    run_angle = random.random()
    if run_angle > 0.5:
        run_angle = 1#to right
    else:
        run_angle = -1# to left
    list_angle_box.append(run_angle)
    #print(list_angle_box)
else:
    print("get full list angle box")


### firstly, add the escape direction
## copy the shp files
origin_shp="E:/#ned/#s_A/1w_point.shp"

def copy_shp (source_shp, copied_shp):
    shp_from_where = shapefile.Reader(source_shp)
    duplicated_shp = shapefile.Writer(copied_shp)

    duplicated_shp.fields = shp_from_where.fields[1:]

    for shape_rec in shp_from_where.iterShapeRecords():
        duplicated_shp.record(*shape_rec.record)
        duplicated_shp.shape(shape_rec.shape.__geo_interface__)
    duplicated_shp.close()
#notice, if the shp file storage path is too deep, there will be error "struct.error: unpack requires a buffer of 4 bytes"
copy_shp(source_shp="E:/#ned/store/1w_point.shp",
         copied_shp=origin_shp)


## add angle & mark fields, then assign values
## 1. field type: double, only to store number
def add_shp_field(shp_path, field_name):
    driver = ogr.GetDriverByName("ESRI Shapefile")
    source = driver.Open(shp_path,1)# 0: read only; 1, read and write
    layer = source.GetLayer()

    field_box = []
    layer_define = layer.GetLayerDefn()

    # get all shp field title/name
    for n in range(layer_define.GetFieldCount()):
        field_title = layer_define.GetFieldDefn(n)
        field_box.append(field_title.name)

    # add field "field_name"
    box=[field_name]
    for add_field_name in box:
        if add_field_name in field_box:
            print("#"+ add_field_name + "# already in field")
        else:
            angle_field = ogr.FieldDefn(add_field_name, ogr.OFTReal)
            angle_field.SetPrecision(8)
            layer.CreateField(angle_field)
            print("field " + add_field_name + " had been added")

add_shp_field(shp_path=origin_shp,
              field_name="angle")
add_shp_field(shp_path=origin_shp,
              field_name="mark")
source = None


## 2. add "angle", "mark" value
source_add_value = ogr.Open(origin_shp,1)# 0: read only; 1, read and write
layer_add_value = source_add_value.GetLayer()

i = 0
for feature in layer_add_value:
    name_angle = feature.GetField("angle")
    feature.SetField("angle", list_angle_box[i])

    name_mark = feature.GetField("mark")
    feature.SetField("mark", str(i+1))

    layer_add_value.SetFeature(feature)
    i = i + 1
source_add_value=None


## make store folder for merge
try:
    make_path_merge = "E:\\#ned\\#s_A\\merge\\"
    os.mkdir(make_path_merge)

    make_path_merge = "E:\\#ned\\#s_A\\#step\\"
    os.mkdir(make_path_merge)

    make_path_map = "E:\\#ned\\#s_A\\map\\"
    os.mkdir(make_path_map)
except:
    print("folder merge already exists")


## copy the internal step0
copy_shp(source_shp="E:/#ned/store/step_0.shp",
         copied_shp="E:/#ned/#s_A/merge/internal_step0.shp")
copy_shp(source_shp=origin_shp,
         copied_shp="E:/#ned/#s_A/#step/step_0.shp")

## iterative, calculate the position of different moment points
time_step = 0
while time_step < 50:
    time_step = time_step + 1

    # copy the origin_shp, at this time the internal point is still exist
    from_copy_shp = "E:/#ned/#s_A/#step/step_" + str(time_step - 1) + ".shp"
    calculate_shp = "E:/#ned/#s_A/#step/step_" + str(time_step) + ".shp"
    copy_shp(source_shp=from_copy_shp,
             copied_shp=calculate_shp)

    # delete the internal point, that is the destroyed people
    mark_shp = "E:/#ned/#s_A/merge/internal_step" + str(time_step - 1) + ".shp"

    # collect the mark value that was deleted soon
    dead_point = gpd.read_file(mark_shp)
    dead_point_list = dead_point["mark"].tolist()

    # collect the current exist point
    current_survival_point = gpd.read_file(calculate_shp)
    current_survival_point_list = current_survival_point["mark"].tolist()

    # try to delete the dead point
    try:
        for delete_number in dead_point_list:
            before_update = gpd.read_file(calculate_shp)
            after_update = before_update.drop(before_update[before_update['mark'] == delete_number].index)
            print("delete the " + str(delete_number))

            after_update.to_file(calculate_shp, driver="ESRI Shapefile", encoding="utf-8")
            #print(after_update)
    except:
        print("none destroyed people")

    # add the field for move
    #add_shp_field(shp_path=calculate_shp, field_name="distance")
    dead_point = None

    ####################################
    # prepare the shp layer and geometry
    move_point = ogr.Open(calculate_shp, 1)  # 0: read only; 1, read and write
    move_layer = move_point.GetLayer()
    layer_define = move_layer.GetLayerDefn()
    move_feature = move_layer.GetNextFeature()

    feature = ogr.Feature(layer_define)

    # create the multi-point data set
    faucets = ogr.Geometry(ogr.wkbMultiPoint)
    faucet = ogr.Geometry(ogr.wkbPoint)

    # determine how many points exist
    dead_point_exist = gpd.read_file(calculate_shp)
    mark_list = dead_point_exist["mark"].tolist()
    mark_list_size = len(mark_list)  # get the point number
    angle_list = dead_point_exist["angle"].tolist()

    # define the "update_coordinate" function to update coordinates
    def update_coordinate(x_offset, y_offset, geometry_number):
        # set a set to store point
        update_point = ogr.Geometry(ogr.wkbPoint)
        update_point.SetPoint(0, x_offset, y_offset)
        feature.SetGeometry(update_point)
        # match the original "mark" and "angle" field
        feature.SetField("mark", mark_list[geometry_number])
        feature.SetField("angle", angle_list[geometry_number])
        # create new point in shp, and delete the previous calculate step
        move_layer.CreateFeature(feature)
        move_layer.DeleteFeature(int(geometry_number))
        # the following code is to ensure that the above operation has been updated
        move_layer.SetFeature(feature)

    i = 0
    while i < mark_list_size:
        geom = move_feature.GetGeometryRef()
        # get the current step coordinate
        x = float(geom.GetX())
        y = float(geom.GetY())
        ### take coordinate offset as run direction and velocity, just take 1 route when you calculate
        ### remember to change the run velocity (3)
        ### the escape angle 16, 29, 61 represents the escape direction, and it was calculated manually.
        pai = math.pi / 180    # move_angle is just took for mathematical calculation
        run_velocity = 3
        ### for route A
        if angle_list[i] < 0:  # -74=-90+16, see figure Figure 6
            x_offset = x - math.cos(pai * 16) * run_velocity
            y_offset = y + math.sin(pai * 16) * run_velocity
            # call the "update_coordinate" function
            update_coordinate(x_offset=x_offset, y_offset=y_offset, geometry_number=i)
            # close the shp, avoid using too much memory
            move_feature.Destroy()
            move_feature = move_layer.GetNextFeature()
            i = i + 1
        elif angle_list[i] > 0:  # 106=90+19, here take the trigonometric transformation manually
            x_offset = x + math.cos(pai * 16) * run_velocity
            y_offset = y - math.sin(pai * 16) * run_velocity
            # call the "update_coordinate" function
            update_coordinate(x_offset=x_offset, y_offset=y_offset, geometry_number=i)
            # close the shp, avoid using too much memory
            move_feature.Destroy()
            move_feature = move_layer.GetNextFeature()
            i = i + 1
        ### for route B
        #if angle_list[i] < 0:  # -119=-74-45, see figure Figure 6
            #x_offset = x - math.cos(pai * 29) * run_velocity
            #y_offset = y - math.sin(pai * 29) * run_velocity
            # call the "update_coordinate" function
            #update_coordinate(x_offset=x_offset, y_offset=y_offset, geometry_number=i)
            # close the shp, avoid using too much memory
            #move_feature.Destroy()
            #move_feature = move_layer.GetNextFeature()
            #i = i + 1
        #elif angle_list[i] > 0:  # 151=90+16+45
            #x_offset = x + math.cos(pai * 61) * run_velocity
            #y_offset = y - math.sin(pai * 61) * run_velocity
            # call the "update_coordinate" function
            #update_coordinate(x_offset=x_offset, y_offset=y_offset, geometry_number=i)
            # close the shp, avoid using too much memory
            #move_feature.Destroy()
            #move_feature = move_layer.GetNextFeature()
            #i = i + 1
        ### for route C
        # #for row in Cal_Cursor:#-164=-90-74
        #x_offset = x - math.cos(pai * 74) * run_velocity
        #y_offset = y - math.sin(pai * 74) * run_velocity
        # call the "update_coordinate" function
        #update_coordinate(x_offset=x_offset, y_offset=y_offset, geometry_number=i)
        # close the shp, avoid using too much memory
        #move_feature.Destroy()
        #move_feature = move_layer.GetNextFeature()
        #i = i + 1
        ### for route D
        # get the "run_step"
        #read_run_step = gpd.read_file(calculate_shp)
        #run_step_list = dead_point_exist["run_step"].tolist()
        #if time_step <= run_step_list[i]:  # execution route A
            # to run A left
            #if angle_list[i] < 0:  # -74=-90+16, see figure Figure 6
                #x_offset = x - math.cos(pai * 16) * run_velocity
                #y_offset = y + math.sin(pai * 16) * run_velocity
                # call the "update_coordinate" function
                #update_coordinate(x_offset=x_offset, y_offset=y_offset, geometry_number=i)
                # close the shp, avoid using too much memory
                #move_feature.Destroy()
                #move_feature = move_layer.GetNextFeature()
                #i = i + 1
            #elif angle_list[i] > 0:  # 106=90+19, here take the trigonometric transformation manually
                #x_offset = x + math.cos(pai * 16) * run_velocity
                #y_offset = y - math.sin(pai * 16) * run_velocity
                # call the "update_coordinate" function
                #update_coordinate(x_offset=x_offset, y_offset=y_offset, geometry_number=i)
                # close the shp, avoid using too much memory
                #move_feature.Destroy()
                #move_feature = move_layer.GetNextFeature()
                #i = i + 1
        #else:  # execution route B
            # to run B left
            #if angle_list[i] < 0:  # -119=-74-45, see figure Figure 6
                #x_offset = x - math.cos(pai * 29) * run_velocity
                #y_offset = y - math.sin(pai * 29) * run_velocity
                # call the "update_coordinate" function
                #update_coordinate(x_offset=x_offset, y_offset=y_offset, geometry_number=i)
                # close the shp, avoid using too much memory
                #move_feature.Destroy()
                #move_feature = move_layer.GetNextFeature()
                #i = i + 1
            # to run B right
            #elif angle_list[i] > 0:  # 151=90+16+45
                #x_offset = x + math.cos(pai * 61) * run_velocity
                #y_offset = y - math.sin(pai * 61) * run_velocity
                # call the "update_coordinate" function
                #update_coordinate(x_offset=x_offset, y_offset=y_offset, geometry_number=i)
                # close the shp, avoid using too much memory
                #move_feature.Destroy()
                #move_feature = move_layer.GetNextFeature()
                #i = i + 1
    move_point.Destroy()
    #############
    # select the internal and external point
    # the largest boundary of hazard zone, to change the "time_step+n" representing early warning time,
    # eg n=2 represents the potential victims had 2 s effective early warning time.
    allow_override = True
    cut_shp = "E:/#ned/boundary100/case" + str(time_step+2) + ".shp"# take "str(time_step+2)" represent Early warning time, here EWt=0 s, respons time=2s

    internal_shp = "E:/#ned/#s_A/merge/internal_step" + str(time_step) + ".shp"
    external_shp = "E:/#ned/#s_A/merge/external_step" + str(time_step) + ".shp"

    calculate_shp = "E:/#ned/#s_A/#step/step_" + str(time_step) + ".shp"
    # read shp and set crs, then save to local
    calculated_point = gpd.read_file(calculate_shp)

    try:#set the coordinate system, otherwise it cannot be calculated
        calculated_point = calculated_point.set_crs(epsg=2379)
    except:
        calculated_point = calculated_point.to_crs(epsg=2379)
    calculated_point.to_file(calculate_shp, driver="ESRI Shapefile", encoding="utf-8")
    # reload the point
    point_gpd = gpd.read_file(calculate_shp)
    #print(point_gpd.crs)


    # read shp and set crs, then save to local
    cut_mask = gpd.read_file(cut_shp)
    try:#Geometric operations require a consistent coordinate system with shp
        cut_mask = cut_mask.set_crs(epsg=2379)
    except:
        cut_mask = cut_mask.to_crs(epsg=2379)
    cut_mask.to_file(cut_shp, driver="ESRI Shapefile", encoding="utf-8")
    # reload the polygon
    mask_gpd = gpd.read_file(cut_shp)
    #print(mask_gpd.crs)

    # take "mask_gpd (landslide boundary)" to clip the calculated
    # take 1 point within the initial boundary, so the gpd.clip will work,
    # remember to minus 1 dead point/ number for every step
    get_internal_shp = gpd.clip(point_gpd, mask_gpd)
    # to_file can not covert empty dataframe to shp
    if get_internal_shp.empty:
        copy_shp(source_shp="E:/#ned/store/internal_step0.shp",
                 copied_shp=internal_shp)
    else:
        get_internal_shp.to_file(internal_shp, driver="ESRI Shapefile", encoding="utf-8")
    # delete useless field
    try:
        df = gpd.read_file(internal_shp)
        delete_field_internal_shp = df.drop(["Name", "CID", "LowPS", "LowPS", "HighPS", "MaxPS", "Tag", "Category",
                                  "GroupName", "CenterX", "CenterY", "ZOrder", "TypeID", "ItemTS", "UriHash"], axis=1)
        delete_field_internal_shp.to_file(internal_shp)
        print(delete_field_internal_shp)
    except:
        print("delete noting fields")
    # take the external point, at time=x, the external+internal=calculated point
    # select the points that lie inside the boundary
    # when we take "overlay","sjoin", if the data set is too big, an error "single positional indexer is out-of-bounds“ will appear
    # read shp and set crs, then save to local
    reload_internal_shp=gpd.read_file(internal_shp)
    try:
        reload_internal_shp = reload_internal_shp.set_crs(epsg=2379)
    except:
        reload_internal_shp = reload_internal_shp.to_crs(epsg=2379)
    reload_internal_shp.to_file(internal_shp, driver="ESRI Shapefile", encoding="utf-8")
    reload_internal_shp=gpd.read_file(internal_shp)

    SymDiff_analysis = gpd.overlay(point_gpd, reload_internal_shp, how="symmetric_difference")
    SymDiff_analysis.to_file(external_shp, driver="ESRI Shapefile", encoding="utf-8")
    if SymDiff_analysis.empty:
        copy_shp(source_shp="E:/#ned/#s_A/#step/step_" + str(time_step) + ".shp",
                 copied_shp=external_shp)
    else:
        SymDiff_analysis.to_file(external_shp, driver="ESRI Shapefile", encoding="utf-8")

    # statistic the survival human number
    internal_count_survival = gpd.read_file(internal_shp)
    count_number = internal_count_survival["angle"].tolist()#you can take any field, except for Null value
    survivors_number = len(count_number)

    print("A step_" + str(time_step) + " survivors number:" + str(survivors_number))
    # write the number of survivors
    f = open("E:/#ned/survival_number_A.txt", 'a')
    f.write("step_" + str(time_step) + " Survivors number:" + str(survivors_number) + "\n")
    f.close()

### the following code is designed for selecting the destroyed points (dead position),
### you'd better not use the following codes with previous step.
## 1. get the dead point list
mark_shp = "A_warning_awareness_external_step50.shp"
destroyed_position = gpd.read_file(mark_shp)
destroy_box = destroyed_position["mark"].tolist()

origin_shp="F:/human vulnerability/5_cal/2.Warning/V=3, T=8/#s_A/1w_point.shp"
calculate_shp = "A_warning_awareness_destroy.shp"
# copy the shp files
def copy_shp (source_shp, copied_shp):
    shp_from_where = shapefile.Reader(source_shp)
    duplicated_shp = shapefile.Writer(copied_shp)

    duplicated_shp.fields = shp_from_where.fields[1:]

    for shape_rec in shp_from_where.iterShapeRecords():
        duplicated_shp.record(*shape_rec.record)
        duplicated_shp.shape(shape_rec.shape.__geo_interface__)
    duplicated_shp.close()
copy_shp(source_shp=origin_shp,
         copied_shp=calculate_shp)
## delect the dead point from the step_0
current_survival_point = gpd.read_file(calculate_shp)
current_survival_point_list = current_survival_point["mark"].tolist()

try:
    for delete_number in destroy_box:
        before_update = gpd.read_file(calculate_shp)
        after_update = before_update.drop(before_update[before_update["mark"] == delete_number].index)
        print("delete the " + str(delete_number))

        after_update.to_file(calculate_shp, driver="ESRI Shapefile", encoding="utf-8")
        print("delete the " + str(delete_number))
except:
    print("none destroyed people")

del destroy_box[:]
# get the survivor point from the origin calculated shp
SymDiff_analysis = gpd.overlay(origin_shp, calculate_shp, how="symmetric_difference")
SymDiff_analysis.to_file(survivor_shp)